"""test_chatbot_symptomes.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1T64aYuHX4gPGu1cu5BOzD8FJIbhJjiWR
"""

#!pip install deep-translator
#!pip install flask_cors
import pandas as pd
from deep_translator import GoogleTranslator
from sentence_transformers import SentenceTransformer, util
from flask import Flask, request, jsonify
import openai
from g4f.client import Client #Remplacement d'openai par g4f
from flask_cors import CORS
import logging
import json

# Configurer le logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Charger le dataset
file_path = "scripts/symbipredict_2022.csv"
df = pd.read_csv(file_path)

# Extraire la liste des sympt√¥mes en anglais
symptoms_english = list(df.columns[:-1])  # Exclure la colonne "prognosis"

# Initialiser le traducteur et le mod√®le d'embeddings
translator = GoogleTranslator(source='auto', target='en')
model = SentenceTransformer('all-MiniLM-L6-v2')

# Encoder les sympt√¥mes du dataset
symptom_embeddings = model.encode(symptoms_english, convert_to_tensor=True)

# Initialiser Flask
app = Flask(__name__)
CORS(app)  # Permet les requ√™tes cross-origin


def find_matching_symptoms(user_input):
    """
    Traduit l'entr√©e utilisateur, recherche une correspondance exacte ou approximative.
    """
    logging.info(f"Sympt√¥me saisi : {user_input}")

    # Traduire le sympt√¥me en anglais
    translated_symptom = translator.translate(user_input)
    logging.info(f"Traduction en anglais : {translated_symptom}")

    # V√©rifier correspondance exacte
    if translated_symptom in symptoms_english:
        best_match =  translated_symptom

    else:
        # Recherche la meilleure correspondance avec embeddings
        input_embedding = model.encode(translated_symptom, convert_to_tensor=True)
        similarity_scores = util.pytorch_cos_sim(input_embedding, symptom_embeddings)[0]
        best_match_idx = similarity_scores.argmax().item()
        best_match = symptoms_english[best_match_idx]
    
    best_match_fr = GoogleTranslator(source='en', target='fr').translate(best_match)
    logging.info(f"Meilleure correspondance trouv√©e : {best_match} {best_match_fr}(score : {similarity_scores[best_match_idx]:.2f})")

    return best_match, best_match_fr

@app.route('/extract_symptoms', methods=['POST'])
def extract_symptoms():
    """ API route pour extraire plusieurs sympt√¥mes """
    data = request.get_json()
    user_message = data.get("message", "")

    if not user_message:
        return jsonify({"error": "Message is required."}), 400

    # Extraire tous les sympt√¥mes trouv√©s dans le message
    detected_symptoms_en = []
    detected_symptoms_fr = []

    for word in user_message.split(","):  # S√©parer les sympt√¥mes par virgule
        symptom_en, symptom_fr = find_matching_symptoms(word.strip())
        detected_symptoms_en.append(symptom_en)
        detected_symptoms_fr.append(symptom_fr)

    return jsonify({
        "symptoms_en": detected_symptoms_en,
        "symptoms_fr": detected_symptoms_fr
    })
    
@app.route('/generate_response', methods=['POST'])
@app.route('/generate_response', methods=['POST'])
def generate_response():
    """ G√©n√©rer une r√©ponse explicative en fran√ßais """
    data = request.get_json()
    logging.info(f"üìù Requ√™te re√ßue par /generate_response : {data}")

    symptoms = data.get("symptoms", [])
    diagnosis = data.get("diagnosis", "")

    if not symptoms or not diagnosis:
        return jsonify({"error": "Veuillez fournir une liste de sympt√¥mes et un diagnostic."}), 400

    if isinstance(symptoms, str):
        symptoms = [symptoms]  # Convertir en liste si c'est une string unique

    # Construire le prompt en fran√ßais
    prompt = f"Le patient pr√©sente les sympt√¥mes suivants : {', '.join(symptoms)}. Le diagnostic est {diagnosis}. Peux-tu expliquer ce dernier de mani√®re simple en fran√ßais et donner des conseils de traitement ?"

    logging.info(f"üß† Prompt envoy√© √† GPT : {prompt}")

    # Appel de l'API GPT (g4f)
    client = Client()
    response = client.chat.completions.create(
        model="gpt-4o-mini",
        messages=[{"role": "user", "content": prompt}],
        web_search=False
    )

    explanation = response.choices[0].message.content

    # Nettoyer la r√©ponse
    explanation_clean = explanation.strip()
    explanation_clean = explanation_clean[0].upper() + explanation_clean[1:]

    logging.info("‚úÖ R√©ponse g√©n√©r√©e avec succ√®s")

    return jsonify({"response": explanation_clean})

if __name__ == '__main__':
    app.run(port=5001, debug=True)